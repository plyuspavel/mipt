Обработка аргументов командной строки. Библиотека sys. Декораторы
#################################################################

:date: 2019-09-19 19:00
:summary: Обработка аргументов командной строки. Библиотека sys. Декораторы
:status: published

.. default-role:: code

.. role:: python(code)
   :language: python

.. raw:: html

  <style>
  .contents li{
    list-style:none;
    padding:0px 0px 0px 2em;
    margin:0px;
  }
  </style>


.. contents::

Обработка аргументов командной строки. Запуск   программы   с   аргументами
===========================================================================

Параметры запуска, задаваемые через командную строку, чаще всего используют консольные программы, хотя программы с графическим интерфейсом тоже не брезгуют этой возможностью. Наверняка в жизни каждого программиста была ситуация, когда приходилось разбирать параметры командной строки, как правило, это не самая интересная часть программы, но без нее не обойтись. Эта статья посвящена тому, как Python облегчает жизнь программистам при решении этой задачи благодаря своей стандартной библиотеке argparse. 

Примеры без использования argparse
----------------------------------

Путь для начала у нас есть простейший скрипт на Python. Для определенности назовем скрипт coolprogram.py, это будет классический Hello World, над которым мы будем работать 

.. code:: python3

   if __name__ == "__main__":
      print ("Привет, мир!")
      
Мы завершили эту сложнейшую программу и отдали ее заказчику, он доволен, но просит добавить в нее возможность указывать имя того, кого приветствуем, причем этот параметр может быть не обязательным. Т.е. программа может использоваться двумя путями:

.. code:: python3

      $ python coolprogram.py
или

.. code:: python3

      $ python coolprogram.py Вася
   
Мы можем воспользоваться переменной argv из модуля sys. sys.argv содержит список параметров, переданных программе через командную строку, причем нулевой элемент списка - это имя нашего скрипта. Т.е. если у нас есть следующий скрипт с именем params.py:

.. code:: python3

   import sys

   if __name__ == "__main__":
       for param in sys.argv:
           print (param)
        
и мы запускаем его с помощью команды

.. code:: python3

   python params.py

то в консоль будет выведена единственная строка:

.. code:: python3

   params.py

Если же мы добавим несколько параметров,

.. code:: python3

   python params.py param1 param2 param3

то эти параметры мы увидим в списке sys.argv, начиная с первого элемента:

.. code:: python3

   params.py
   param1
   param2
   param3

Здесь можно обратить внимание на то, что ссылка на интерпретатор Python в список этих параметров не входит, хотя он также присутствует в строке вызова нашего скрипта.

Вернемся к нашей задаче. Погрузившись в код на неделю, мы могли бы выдать заказчику следующий скрипт:

.. code:: python3

   import sys

   if __name__ == "__main__":
       if len (sys.argv) > 1:
           print ("Привет, {}!".format (sys.argv[1] ) )
       else:
           print ("Привет, мир!")

Теперь, если программа вызывается с помощью команды

.. code:: python3

   python coolprogram.py
   
то результат будет прежний

.. code:: python3

   Привет, мир!
   
а если мы добавим параметр:

.. code:: python3

   python coolprogram.py Вася
   
то программа поприветствует некоего Васю:

.. code:: python3
   Привет, Вася!
   
Пока все легко и никаких проблем не возникает. Теперь предположим, что требования заказчика вновь изменились, и на этот раз он хочет, чтобы имя приветствуемого человека передавалось после именованного параметра --name или -n, причем нужно следить, что в командной строке передано только одно имя. С этого момента у нас начнется вермишель из конструкций if.

.. code:: python3

   import sys

   if __name__ == "__main__":
       if len (sys.argv) == 1:
           print ("Привет, мир!")
       else:
           if len (sys.argv) < 3:
               print ("Ошибка. Слишком мало параметров.")
               sys.exit (1)

           if len (sys.argv) > 3:
               print ("Ошибка. Слишком много параметров.")
               sys.exit (1)

           param_name = sys.argv[1]
           param_value = sys.argv[2]

           if (param_name == "--name" or
                   param_name == "-n"):
               print ("Привет, {}!".format (param_value) )
           else:
               print ("Ошибка. Неизвестный параметр '{}'".format (param_name) )
               sys.exit (1)

Здесь мы проверяем ситуацию, что мы вообще не передали ни одного параметра, потом проверяем, что дополнительных параметров у нас ровно два, что они называются именно --name или -n, и, если нас все устраивает, выводим приветствие.

Как видите, код превратился в тихий ужас. Изменить логику работы в нем в дальнейшем будет очень сложно, а при увеличении количества параметров нужно будет срочно применять объектно-ориентированные меры по отделению логики работы программы от разбора командной строки. Разбор командной строки мы могли бы выделить в отдельный класс (или классы), но мы этого здесь делать не будем, поскольку все уже сделано в стандартной библиотеке Python, которая называется argparse.

Но перед тем, как перейти к библиотеке argparse, еще немного остановимся на sys.
Модуль sys обеспечивает доступ к некоторым переменным и функциям, взаимодействующим с интерпретатором python.
Самыми полезными являются:
   * sys.argv - список аргументов командной строки, передаваемых сценарию Python. sys.argv[0] является именем скрипта (пустой строкой в интерактивной оболочке).
   * sys.exit([arg]) - выход из Python. Функция exit принимает необязательный аргумент, обычно целое число, которое дает статус выхода. Ноль считается как успешное завершение. Обязательно проверьте, имеет ли ваша операционная система какие-либо особые значения для своих статусов выхода, чтобы вы могли следить за ними в своем собственном приложении. Обратите внимание на то, что когда вы вызываете exit, это вызовет исключение SystemExit, которое позволяет функциям очистки работать в конечных пунктах блоков try / except. 
   * sys.stdin - стандартный поток ввода.
   * sys.stdout - стандартный поток вывода.
   * sys.stderr - стандартный поток ошибок. 
   Stdin, stdout и stderr сопоставляются с файловыми объектами, которые соответствуют стандартным входам, выходам и потокам ошибок интерпретатора соответственно. Функция stdin используется для всех входов, используемых интерпретатором (за исключением скриптов), тогда как stdout используется для выходов операторов print. Эти потоки вывода можно переопределить, например для перенаправления логов вывода в графический интерфейс или в файл.
   * sys.__stdin__, sys.__stdout__, sys.__stderr__ - исходные значения потоков ввода, вывода и ошибок.

Использование библиотеки argparse
---------------------------------

Простейший случай
-----------------

Как как было сказано выше, стандартная библиотека argparse предназначена для облегчения разбора командной строки. На нее можно возложить проверку переданных параметров: их количество и обозначения, а уже после того, как эта проверка будет выполнена автоматически, использовать полученные параметры в логике своей программы.

Основа работы с командной строкой в библиотеке argparse является класс ArgumentParser. У его конструктора и методов довольно много параметров, все их рассматривать не будем, поэтому в дальнейшем рассмотрим работу этого класса на примерах, попутно обсуждая различные параметры.

Простейший принцип работы с argparse следующий:

   1. Создаем экземпляр класса ArgumentParser.
   2. Добавляем в него информацию об ожидаемых параметрах с помощью метода add_argument (по одному вызову на каждый параметр).
   3. Разбираем командную строку помощью метода parse_args, передавая ему полученные параметры командной строки (кроме нулевого элемента списка sys.argv).
   4. Начинаем использовать полученные параметры.
   
Для начала перепишем программу coolprogram.py с единственным параметром так, чтобы она использовала библиотеку argparse. Напомню, что данном случае мы ожидаем следующий синтаксис параметров:

python coolprogram.py [Имя]

Здесь [Имя] является необязательным параметром.

Наша программа с использованием argparse может выглядеть следующим образом:

#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import sys
import argparse
 
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('name', nargs='?')
 
    return parser
 
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
 
    # print (namespace)
 
    if namespace.name:
        print ("Привет, {}!".format (namespace.name) )
    else:
        print ("Привет, мир!")
Исходник
На первый взгляд эта программа работает точно так же, как и раньше, хотя есть отличия, но мы их рассмотрим чуть позже. Пока разберемся с тем, что мы понаписали в программе.

Создание парсера вынесено в отдельную функцию, поскольку эта часть программы в будущем будет сильно изменяться и разрастаться. На строке 9 мы создали экземпляр класса ArgumentParser с параметрами по умолчанию. Что это за параметры, опять же, поговорим чуть позже.

На строке 10 мы добавили ожидаемый параметр в командной строке с помощью метода add_argument. При этом такой параметр будет считаться позиционным, т.е. он должен стоять именно на этом месте и у него не будет никаких предварительных обозначений (мы их добавим позже в виде '-n' или '--name'). Если бы мы не добавили именованный параметр nargs='?', то этот параметр был бы обязательным. nargs может принимать различные значения. Если бы мы ему присвоили целочисленное значение больше 0, то это бы означало, что мы ожидаем ровно такое же количество передаваемых параметров (точнее, считалось бы, что первый параметр ожидал бы список из N элементов, разделенных пробелами, этот случай мы рассмотрим позже). Также этот параметр может принимать значение '?', '+', '*' и argparse.REMAINDER. Мы их не будем рассматривать, поскольку они важны в сочетании с необязательными именованными параметрами, которые могут располагаться как до, так и после нашего позиционного параметра. Тогда этот параметр будет показывать как интерпретировать список параметров, где будет заканчиваться один список параметров и начинаться другой.

Итак, мы создали парсер, после чего можно вызвать его метод parse_args для разбора командной строки. Если мы не укажем никакого параметра, это будет означать равносильно тому, что мы передадим в него все параметры из sys.argv кроме нулевого, который содержит имя нашей программы. т.е.

parser.parse_args (sys.argv[1:])
Исходник
В качестве результата мы получим экземпляр класса Namespace, который будет содержать в качестве члена имя нашего параметра. Теперь можно раскомментировать строку 19 в приведенном выше примере, чтобы посмотреть, чему же равны наши параметры.

Если мы это сделаем и запустим программу с переданным параметром

python coolprogram.py Вася
Исходник
, то увидим его в пространстве имен.

Namespace(name='Вася')
Исходник
Если же теперь мы запустим программу без дополнительных параметров, то это значение будет равно None:

Namespace(name=None)
Исходник
Мы можем изменить значение по умолчанию, что позволит нам несколько сократить программу. Пусть по умолчанию используется слово 'мир', ведь мы его приветствуем, если параметры не переданы. Для этого воспользуемся дополнительным именованным параметром default в методе add_argument.

#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import sys
import argparse
 
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('name', nargs='?', default='мир')
 
    return parser
 
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args (sys.argv[1:])
 
    # print (namespace)
 
    print ("Привет, {}!".format (namespace.name) )
Исходник
Программа продолжает работать точно также, как и раньше. Вы, наверное, заметили, что в предыдущем примере в метод parse_args на строке 17 передаются параметры командной строки из sys.argv. Это сделано для того, чтобы показать, что список параметров мы можем передавать явно, при необходимости мы его можем предварительно обработать, хотя это вряд ли понадобится, ведь почти всю обработку можно возложить на плечи библиотеки argparse.
